{"ast":null,"code":"import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\n\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\n\n\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\n\nexport default function useResponsiveObserver() {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token)); // To avoid repeat create instance, we add `useMemo` here.\n\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      matchHandlers: {},\n\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n\n      subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n\n      responsiveMap\n    };\n  }, [token]);\n}","map":{"version":3,"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","screens","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","keys","matchMediaQuery","handler","mql","removeListener","listener","clear","_ref","matches","assign","window","matchMedia","addListener"],"sources":["D:/year4sem2/evmos/campaign/node_modules/antd/es/_util/responsiveObserver.js"],"sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport default function useResponsiveObserver() {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      responsiveMap\n    };\n  }, [token]);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}