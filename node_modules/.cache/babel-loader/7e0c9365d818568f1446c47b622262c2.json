{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  var formatRangeValue = React.useCallback(function (val) {\n    var formatNextValue = isFinite(val) ? val : min;\n    formatNextValue = Math.min(max, val);\n    formatNextValue = Math.max(min, formatNextValue);\n    return formatNextValue;\n  }, [min, max]);\n  var formatStepValue = React.useCallback(function (val) {\n    if (step !== null) {\n      var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step; // Cut number in case to be like 0.30000000000000004\n\n      var getDecimal = function getDecimal(num) {\n        return (String(num).split('.')[1] || '').length;\n      };\n\n      var maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      var fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  var formatValue = React.useCallback(function (val) {\n    var formatNextValue = formatRangeValue(val); // List align values\n\n    var alignValues = markList.map(function (mark) {\n      return mark.value;\n    });\n\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    } // min & max\n\n\n    alignValues.push(min, max); // Align with marks\n\n    var closeValue = alignValues[0];\n    var closeDist = max - min;\n    alignValues.forEach(function (alignValue) {\n      var dist = Math.abs(formatNextValue - alignValue);\n\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]); // ========================== Offset ==========================\n  // Single Value\n\n  var offsetValue = function offsetValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n\n    if (typeof offset === 'number') {\n      var nextValue;\n      var originValue = values[valueIndex]; // Only used for `dist` mode\n\n      var targetDistValue = originValue + offset; // Compare next step value & mark value which is best match\n\n      var potentialValues = [];\n      markList.forEach(function (mark) {\n        potentialValues.push(mark.value);\n      }); // Min & Max\n\n      potentialValues.push(min, max); // In case origin value is align with mark but not with step\n\n      potentialValues.push(formatStepValue(originValue)); // Put offset step value also\n\n      var sign = offset > 0 ? 1 : -1;\n\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      } // Find close one\n\n\n      potentialValues = potentialValues.filter(function (val) {\n        return val !== null;\n      }) // Remove reverse value\n      .filter(function (val) {\n        return offset < 0 ? val <= originValue : val >= originValue;\n      });\n\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(function (val) {\n          return val !== originValue;\n        });\n      }\n\n      var compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      var valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(function (potentialValue) {\n        var dist = Math.abs(potentialValue - compareValue);\n\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      }); // Out of range will back to range\n\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      } // `dist` mode\n\n\n      if (mode === 'dist') {\n        return nextValue;\n      } // `unit` mode may need another round\n\n\n      if (Math.abs(offset) > 1) {\n        var cloneValues = _toConsumableArray(values);\n\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n\n\n  var offsetChangedValue = function offsetChangedValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var originValue = values[valueIndex];\n    var nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n\n  var needPush = function needPush(dist) {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  }; // Values\n\n\n  var offsetValues = function offsetValues(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var nextValues = values.map(formatValue);\n    var originValue = nextValues[valueIndex];\n    var nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      var pushNum = pushable || 0; // ============ AllowCross ===============\n\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n      // >>>>>> Basic push\n      // End values\n      for (var i = valueIndex + 1; i < nextValues.length; i += 1) {\n        var changed = true;\n\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);\n\n          nextValues[i] = _offsetChangedValue.value;\n          changed = _offsetChangedValue.changed;\n        }\n      } // Start values\n\n\n      for (var _i = valueIndex; _i > 0; _i -= 1) {\n        var _changed = true;\n\n        while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {\n          var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);\n\n          nextValues[_i - 1] = _offsetChangedValue2.value;\n          _changed = _offsetChangedValue2.changed;\n        }\n      } // >>>>> Revert back to safe push range\n      // End to Start\n\n\n      for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {\n        var _changed2 = true;\n\n        while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {\n          var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);\n\n          nextValues[_i2 - 1] = _offsetChangedValue3.value;\n          _changed2 = _offsetChangedValue3.changed;\n        }\n      } // Start to End\n\n\n      for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {\n        var _changed3 = true;\n\n        while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {\n          var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);\n\n          nextValues[_i3 + 1] = _offsetChangedValue4.value;\n          _changed3 = _offsetChangedValue4.changed;\n        }\n      }\n    }\n\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n\n  return [formatValue, offsetValues];\n}","map":{"version":3,"names":["_toConsumableArray","React","useOffset","min","max","step","markList","allowCross","pushable","formatRangeValue","useCallback","val","formatNextValue","isFinite","Math","formatStepValue","stepValue","round","getDecimal","num","String","split","length","maxDecimal","fixedValue","Number","toFixed","formatValue","alignValues","map","mark","value","push","closeValue","closeDist","forEach","alignValue","dist","abs","offsetValue","values","offset","valueIndex","mode","arguments","undefined","nextValue","originValue","targetDistValue","potentialValues","sign","filter","compareValue","valueDist","potentialValue","cloneValues","offsetChangedValue","changed","needPush","offsetValues","nextValues","pushNum","i","_offsetChangedValue","_i","_changed","_offsetChangedValue2","_i2","_changed2","_offsetChangedValue3","_i3","_changed3","_offsetChangedValue4"],"sources":["D:/year4sem2/evmos/campaign/node_modules/rc-slider/es/hooks/useOffset.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nexport default function useOffset(min, max, step, markList, allowCross, pushable) {\n  var formatRangeValue = React.useCallback(function (val) {\n    var formatNextValue = isFinite(val) ? val : min;\n    formatNextValue = Math.min(max, val);\n    formatNextValue = Math.max(min, formatNextValue);\n    return formatNextValue;\n  }, [min, max]);\n  var formatStepValue = React.useCallback(function (val) {\n    if (step !== null) {\n      var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step;\n      // Cut number in case to be like 0.30000000000000004\n      var getDecimal = function getDecimal(num) {\n        return (String(num).split('.')[1] || '').length;\n      };\n      var maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min));\n      var fixedValue = Number(stepValue.toFixed(maxDecimal));\n      return min <= fixedValue && fixedValue <= max ? fixedValue : null;\n    }\n    return null;\n  }, [step, min, max, formatRangeValue]);\n  var formatValue = React.useCallback(function (val) {\n    var formatNextValue = formatRangeValue(val);\n    // List align values\n    var alignValues = markList.map(function (mark) {\n      return mark.value;\n    });\n    if (step !== null) {\n      alignValues.push(formatStepValue(val));\n    }\n    // min & max\n    alignValues.push(min, max);\n    // Align with marks\n    var closeValue = alignValues[0];\n    var closeDist = max - min;\n    alignValues.forEach(function (alignValue) {\n      var dist = Math.abs(formatNextValue - alignValue);\n      if (dist <= closeDist) {\n        closeValue = alignValue;\n        closeDist = dist;\n      }\n    });\n    return closeValue;\n  }, [min, max, markList, step, formatRangeValue, formatStepValue]);\n  // ========================== Offset ==========================\n  // Single Value\n  var offsetValue = function offsetValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    if (typeof offset === 'number') {\n      var nextValue;\n      var originValue = values[valueIndex];\n      // Only used for `dist` mode\n      var targetDistValue = originValue + offset;\n      // Compare next step value & mark value which is best match\n      var potentialValues = [];\n      markList.forEach(function (mark) {\n        potentialValues.push(mark.value);\n      });\n      // Min & Max\n      potentialValues.push(min, max);\n      // In case origin value is align with mark but not with step\n      potentialValues.push(formatStepValue(originValue));\n      // Put offset step value also\n      var sign = offset > 0 ? 1 : -1;\n      if (mode === 'unit') {\n        potentialValues.push(formatStepValue(originValue + sign * step));\n      } else {\n        potentialValues.push(formatStepValue(targetDistValue));\n      }\n      // Find close one\n      potentialValues = potentialValues.filter(function (val) {\n        return val !== null;\n      })\n      // Remove reverse value\n      .filter(function (val) {\n        return offset < 0 ? val <= originValue : val >= originValue;\n      });\n      if (mode === 'unit') {\n        // `unit` mode can not contain itself\n        potentialValues = potentialValues.filter(function (val) {\n          return val !== originValue;\n        });\n      }\n      var compareValue = mode === 'unit' ? originValue : targetDistValue;\n      nextValue = potentialValues[0];\n      var valueDist = Math.abs(nextValue - compareValue);\n      potentialValues.forEach(function (potentialValue) {\n        var dist = Math.abs(potentialValue - compareValue);\n        if (dist < valueDist) {\n          nextValue = potentialValue;\n          valueDist = dist;\n        }\n      });\n      // Out of range will back to range\n      if (nextValue === undefined) {\n        return offset < 0 ? min : max;\n      }\n      // `dist` mode\n      if (mode === 'dist') {\n        return nextValue;\n      }\n      // `unit` mode may need another round\n      if (Math.abs(offset) > 1) {\n        var cloneValues = _toConsumableArray(values);\n        cloneValues[valueIndex] = nextValue;\n        return offsetValue(cloneValues, offset - sign, valueIndex, mode);\n      }\n      return nextValue;\n    } else if (offset === 'min') {\n      return min;\n    } else if (offset === 'max') {\n      return max;\n    }\n  };\n  /** Same as `offsetValue` but return `changed` mark to tell value changed */\n  var offsetChangedValue = function offsetChangedValue(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var originValue = values[valueIndex];\n    var nextValue = offsetValue(values, offset, valueIndex, mode);\n    return {\n      value: nextValue,\n      changed: nextValue !== originValue\n    };\n  };\n  var needPush = function needPush(dist) {\n    return pushable === null && dist === 0 || typeof pushable === 'number' && dist < pushable;\n  };\n  // Values\n  var offsetValues = function offsetValues(values, offset, valueIndex) {\n    var mode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'unit';\n    var nextValues = values.map(formatValue);\n    var originValue = nextValues[valueIndex];\n    var nextValue = offsetValue(nextValues, offset, valueIndex, mode);\n    nextValues[valueIndex] = nextValue;\n    if (allowCross === false) {\n      // >>>>> Allow Cross\n      var pushNum = pushable || 0;\n      // ============ AllowCross ===============\n      if (valueIndex > 0 && nextValues[valueIndex - 1] !== originValue) {\n        nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum);\n      }\n      if (valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue) {\n        nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum);\n      }\n    } else if (typeof pushable === 'number' || pushable === null) {\n      // >>>>> Pushable\n      // =============== Push ==================\n      // >>>>>> Basic push\n      // End values\n      for (var i = valueIndex + 1; i < nextValues.length; i += 1) {\n        var changed = true;\n        while (needPush(nextValues[i] - nextValues[i - 1]) && changed) {\n          var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);\n          nextValues[i] = _offsetChangedValue.value;\n          changed = _offsetChangedValue.changed;\n        }\n      }\n      // Start values\n      for (var _i = valueIndex; _i > 0; _i -= 1) {\n        var _changed = true;\n        while (needPush(nextValues[_i] - nextValues[_i - 1]) && _changed) {\n          var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);\n          nextValues[_i - 1] = _offsetChangedValue2.value;\n          _changed = _offsetChangedValue2.changed;\n        }\n      }\n      // >>>>> Revert back to safe push range\n      // End to Start\n      for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) {\n        var _changed2 = true;\n        while (needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2) {\n          var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);\n          nextValues[_i2 - 1] = _offsetChangedValue3.value;\n          _changed2 = _offsetChangedValue3.changed;\n        }\n      }\n      // Start to End\n      for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) {\n        var _changed3 = true;\n        while (needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3) {\n          var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);\n          nextValues[_i3 + 1] = _offsetChangedValue4.value;\n          _changed3 = _offsetChangedValue4.changed;\n        }\n      }\n    }\n    return {\n      value: nextValues[valueIndex],\n      values: nextValues\n    };\n  };\n  return [formatValue, offsetValues];\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}