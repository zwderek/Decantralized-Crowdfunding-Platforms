{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport MutateObserver from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport React, { useEffect, useRef } from 'react';\nimport { getPixelRatio, getStyleStr, reRendering, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\n\nconst BaseSize = 2;\nconst FontGap = 3;\n\nconst Watermark = props => {\n  var _a, _b;\n\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const stopObservation = useRef(false);\n\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n\n    if (containerRef.current && watermarkRef.current) {\n      stopObservation.current = true;\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current); // Delayed execution\n\n      setTimeout(() => {\n        stopObservation.current = false;\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n\n\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n\n      if (image) {\n        const img = new Image();\n\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n        /** Fill the interleaved text after rotation */\n\n        ctx.restore();\n        rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n        fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n        appendWatermark(canvas.toDataURL(), markWidth);\n      }\n    }\n  };\n\n  const onMutate = mutations => {\n    if (stopObservation.current) {\n      return;\n    }\n\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, watermarkRef.current)) {\n        destroyWatermark();\n        renderWatermark();\n      }\n    });\n  };\n\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(MutateObserver, {\n    onMutate: onMutate\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children));\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\n\nexport default Watermark;","map":{"version":3,"names":["_toConsumableArray","MutateObserver","classNames","React","useEffect","useRef","getPixelRatio","getStyleStr","reRendering","rotateWatermark","BaseSize","FontGap","Watermark","props","_a","_b","zIndex","rotate","width","height","image","content","font","style","className","rootClassName","gap","offset","children","color","fontSize","fontWeight","fontStyle","fontFamily","gapX","gapY","gapXCenter","gapYCenter","offsetLeft","offsetTop","getMarkStyle","markStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","containerRef","watermarkRef","stopObservation","destroyWatermark","current","remove","undefined","appendWatermark","base64Url","markWidth","setAttribute","Object","assign","backgroundImage","backgroundSize","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","Number","contents","Array","isArray","widths","map","item","Math","ceil","max","apply","length","fillTexts","drawX","drawY","drawWidth","drawHeight","ratio","mergedFontSize","fillStyle","textAlign","textBaseline","translate","forEach","index","fillText","renderWatermark","canvas","document","createElement","getContext","markHeight","canvasWidth","canvasHeight","rotateX","rotateY","alternateDrawX","alternateDrawY","alternateRotateX","alternateRotateY","save","img","Image","onload","drawImage","restore","toDataURL","crossOrigin","referrerPolicy","src","onMutate","mutations","mutation","ref","process","env","NODE_ENV","displayName"],"sources":["D:/year4sem2/evmos/campaign/node_modules/antd/es/watermark/index.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport MutateObserver from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport React, { useEffect, useRef } from 'react';\nimport { getPixelRatio, getStyleStr, reRendering, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const stopObservation = useRef(false);\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n    if (containerRef.current && watermarkRef.current) {\n      stopObservation.current = true;\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current);\n      // Delayed execution\n      setTimeout(() => {\n        stopObservation.current = false;\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n        /** Fill the interleaved text after rotation */\n        ctx.restore();\n        rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n        fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n        appendWatermark(canvas.toDataURL(), markWidth);\n      }\n    }\n  };\n  const onMutate = mutations => {\n    if (stopObservation.current) {\n      return;\n    }\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, watermarkRef.current)) {\n        destroyWatermark();\n        renderWatermark();\n      }\n    });\n  };\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(MutateObserver, {\n    onMutate: onMutate\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;"],"mappings":"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"},"metadata":{},"sourceType":"module"}